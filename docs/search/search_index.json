{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Incendia Technologies","text":"<p>Incindia is an Anonymous Voting via Proof-of-Burn</p> <p>This repository delivers a Rust-based, fully on-chain anonymous voting system leveraging proof-of-burn and zero-knowledge proofs (zk-SNARKs) to enable privacy-preserving, verifiable voting on Ethereum-compatible networks.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>Fully on-chain: No trusted third parties or off-chain tallying required.</p> <p>Anonymity </p> <p>coercion-resistant</p> <p>Flexible voting schemes</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Start using the project now!</p>"},{"location":"#repo-and-paper","title":"Repo and paper","text":"<p>Paper Github Repo</p>"},{"location":"#citations","title":"Citations","text":"<p>If citing this work in research or production, reference:</p> <pre><code>@misc{cryptoeprint:2025/1022,\n      author = {Stefan Dziembowski and Shahriar Ebrahimi and Haniyeh Habibi and Parisa Hassanizadeh and Pardis Toolabi},\n      title = {Burn Your Vote: Decentralized and Publicly Verifiable Anonymous Voting at Scale},\n      howpublished = {Cryptology {ePrint} Archive, Paper 2025/1022},\n      year = {2025},\n      url = {https://eprint.iacr.org/2025/1022}\n}\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Prerequisites</p> <p>Node.js (\u226516.0.0)</p> <p>Rust (Cargo)</p> <p>Circom</p> <p>Homebrew (macOS)</p> <p>1-Setup</p> <p>This sets up all required dependencies including Circomlib, snarkjs, ganache-cli, and Rapidsnark.</p> <pre><code>git clone git@github.com:zero-savvy/burn-to-vote.git\ncd burn-to-vote\nnpm run install-deps\n</code></pre> <p>2-Run a local blockchain</p> <p>Start development and testing on a local Ethereum network.</p> <pre><code>ganache-cli\nexport PRIVATE_KEY=[YOUR_PRIVATE_KEY]\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Initiate a Ceremony</p> <p>Generates initial voting setup parameters for Ganache, Sepolia, or Ethereum.</p> <pre><code>cargo run -- initiate --network [NETWORK]\n\n</code></pre> <p>Vote</p> <p>Burns ETH, creates the proof, and submits the vote. If you don\u2019t specify a ceremony ID, it uses the latest generated one. </p> <pre><code>cargo run -- vote \\\n  --amount [ETH] \\\n  --vote [VOTE_VALUE] \\\n  --revote [REVOTE_FLAG] \\\n  --private-key [PRIVATE_KEY] \\\n  --ceremony-id [CEREMONY_ID]\n\n</code></pre> <p>Tally</p> <p>Calculates and outputs results after the tally deadline. Defaults to the latest ceremony if ID isn\u2019t provided.</p> <pre><code>cargo run -- tally --ceremony-id [CEREMONY_ID]\n\n</code></pre> <p>Demo (Offline, Fast) Runs a full in-memory ceremony (proof generation, verification, Merkle tree handling) without on-chain integration.</p> <pre><code>cargo run -- demo [PRIVATE_KEY]\n\n</code></pre> <p>On-chain Demo Deploys smart contracts on-chain, submits a sample proof, and retrieves tally results. </p> <pre><code>make contracts\ncargo run -- onchain-demo [PRIVATE_KEY]\n\n</code></pre>"},{"location":"dev/architecture/","title":"Architecture","text":"<p>The system architecture has two major components:</p> <p>Smart Contracts: manage ceremony creation, vote submission, and tallying.</p> <p>Burn Circuits: Circom circuits enforcing the validity of burn addresses, nullifiers, and Merkle proofs.</p>"},{"location":"dev/architecture/#smart-contract-architecture","title":"Smart Contract Architecture","text":""},{"location":"dev/architecture/#votingfactory","title":"VotingFactory","text":"<p>location: <code>contracts/src/VotingFactory.sol</code></p> <p>Factory contract is responsible for deploying new voting ceremonies contracts with following parameters:</p> <ul> <li> <p>Verifier Address: Deployed Groth16 verifier (BN254)</p> </li> <li> <p>Voting Deadline: UNIX timestamp to lock voting</p> </li> <li> <p>Tally Deadline: UNIX timestamp, after this anyone can call tallyVotes() function</p> </li> <li> <p>Merkle Root: Allow-list root for eligible voters ids</p> </li> <li> <p>State Root: Ethereum state root at voting end (for verifying burn balances)</p> </li> <li> <p>Ceremony ID: Unique voting identifier</p> </li> <li> <p>Salt: Unique salt for deterministic contract address generation</p> </li> </ul>"},{"location":"dev/architecture/#voting-contract","title":"Voting Contract","text":"<p>location: <code>contracts/src/Voting.sol</code></p> <p>Each deployed voting contract instance implements the core voting logic:</p> <p>Key functions: - <code>submitVote(proofA, proofB, proofC, [nullifier, voteValue, revoteFlag, stateRoot, merkleProof, ceremonyId])</code>: Submits a vote with a zero-knowledge proof - <code>submitRevote(...)</code>: Overwrites a previous vote if the nullifier matches - <code>tallyVotes()</code>: Computes and publishes the final outcome after the tally deadline</p> <p>The factory pattern allows for: - Deterministic contract addresses based on salt - Multiple concurrent voting instances - Gas-efficient deployment of new voting contracts - Easy tracking of all deployed voting instances</p>"},{"location":"dev/architecture/#circom-circuits","title":"Circom Circuits","text":"<p>Under <code>circuits/</code>:</p> <ul> <li><code>Vote.circom</code>:  </li> <li>Computes burn address: <code>address == H(secret \u2225 ceremonyID \u2225 vote \u2225 blindingFactor)</code>.  </li> <li>Computes nullifier: <code>address == H(secret \u2225 ceremonyID \u2225 blindingFactor)</code>.  </li> <li>Verifies Merkle Patricia inclusion (<code>stateRoot</code>, <code>accountRLP</code>, <code>accountProof</code>).  </li> <li><code>rlp.circom</code>: Supporting subcircuits.</li> </ul>"}]}